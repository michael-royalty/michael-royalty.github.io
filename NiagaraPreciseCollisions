You can enable precise collisions in Niagara using HLSL and modifying the base PDB intra-particle collisions scratchpad to support it.

What's supported:
Spherical particles checking against shaped particles for collision

What's not supported:
Shaped particles checking against shaped particles for collision
Shaped particles checking against spherical particles for collision

Basically, you make a list of shaped particles that can move other less important particles out of their way. For this support, the shaped particles make use of the existing "unyielding" particle logic -- all non-shaped  particles treat shaped particles as unyielding.

All shaped particles should treat each other as spherical and use the regular intra-pdb collisions.

You can make tiers of shaped particles.

Neighbor Grids should be sized based on particle size. If a grid is too large, you include too many particles and checks get inefficient. If it's too small, a large particle could span across multiple grids and not be detected at its edges for collision.

Example of setting up multiple grids:

Tier 2 (Largest): Use a grid with large extents -- extents equal to double the largest particle's length from center to outermost point.
These particles will check the Tier 2 grid for regular intra-particle collision.

Tier 1 (Medium): Use a grid with medium extents
These particles will check the tier 2 grid for shaped intra-particle collision.
These particles will check the tier 1 grid for regular intra-particle collision.

Tier 0 (Small): 
These particles will check the tier 2 grid for shaped intra-particle collision.
These particles will check the tier 1 grid for shaped intra-particle collision.
Theae particles will check the tier 0 grid for regular intra-particle collision.

For cleanliness and efficiency of collisions, you should check all regular collisions first to get a baseline of where objects should be before they're moved by larger objects.
Then check the Tier 1 collisions against the shaped Tier 2 grid.
Lastly check the Tier 2 collisions against the shaped Tier 1 grid.

This lets us get smaller objects to an approximately correct position before the larger objects act on them.
It will result in smaller objects overlapping, but small objects overlapping is less visible than small objects failing to be pushed by larger objects.

What variables do we need?
1: Collision type. Box, Cylinder, or Sphere. Sphere collisions could use the regular intra-particle collisions, but for grid size and batching purposes we may as well combine them.
2: Max Collision Radius. This is a separate stat from Collision Radius, used for an early out when small objects check larger objects for collision.
It should be equal to the length to the longest outlying point.
While we could just us CollisionRadius, we will also be using CollisionRadius for intra-particle collisions. It's useful to keep MaxCollisionRadius (early out) separate from CollisionRadius,
As you may want the collision radius between like-sized particles to be smaller, and we want to use this early-out to eke out all the efficiency we can.
3: Extents (Vector) -- Scale * Mesh Extents. Needed for boxes.
4: Half Height and Radius (floats) -- Scale * Half Height & Radius. Needed for cylinders.
5: CollisionRadius (Float) -- Needed for spheres. Can be calculated by Niagara or manually input.
6: Orientation (Quat) -- Needed for boxes and cylinders. Calculated by Niagara.
7: Size (Integer) -- This will be used to tell particles which neighbor grids they should populate and which collisions they should refer to.

Editing the intra-particle reader is simple.
1: Copy the base reader scratchpad into another directory and rename it.
2: Edit the scratch and add these input pins.
3: Edit the HLSL and add this code block

HLSL CODE HERE

Usage:
Create three neighbor grids, all in the same emitter. (Note: If you're using separate emitters you'll want to create the larger neighbor grids under the system instead)
Populate the three neighbor grids based on the Size variable
Set up one intra-particle reader (or three in the small emitter, two in the medium, and one in the large if you're using 3 separate emitters. Possibly you can set these up at the system level instead)
Set up the three intra-particle checks.
Set up the medium to large Shape check
Set up the small to medium Shape check

You may need to limit the max speed of smaller particles, or make your box shapes thicker, if you see particles going into boxes.

Improvements:
We can make it easier to set up multiple tiers.
Stage 1 (Manual): combine the intra-particle reader to take multiple particle readers and neighbor grids. We can have one intra-particle reader scratch for 2 sizes, and one for 3 sizes.
Stage 2 (Automatic): combine the multiple readers and neighbor grids into an array. Then we can have as many sizes as we want.

Add variables for efficiency and ease of use.
1. MaxCollisionRadius (+CollisionType). Used by boxes and cylinders for early out. Used as CollisionRadius for spheres.
2. Extents. Vector3 used by boxes.
3. HalfHeight and Radius. Vector2 used by cylinders.
4. Orientation. Float4 used by boxes and cylinders.
5. User Parameter Arrays to store mesh-level CollisionRadius, ShapeType, ShapeHalfHeight, and ShapeExtents. Then we can multiply particle scale by these to get the actual values. Simplifies input into Niagara.
6. Mesh (Integer) -- Used to refer to the right element in the User Parameter Arrays
